//#############################################################################
//  File:      AppDemoMainGLFW.cpp
//  Purpose:   The demo application demonstrates most features of the SLProject
//             framework. Implementation of the GUI with the GLFW3 framework
//             that can create a window and receive system event on desktop OS
//             such as Windows, MacOS and Linux.
//  Date:      July 2014
//  Codestyle: https://github.com/cpvrlab/SLProject/wiki/SLProject-Coding-Style
//  Authors:   Marcus Hudritsch
//  License:   This software is provided under the GNU General Public License
//             Please visit: http://opensource.org/licenses/GPL-3.0
//#############################################################################

#include <SLGLState.h>
#include <SLEnums.h>
#include <SLInterface.h>
#include <AppDemo.h>
#include <SLSceneView.h>
#include <SLProjectScene.h>
#include <CVCapture.h>
#include <AppArucoPenGui.h>
#include <AppArucoPenSceneView.h>
#include <GLFW/glfw3.h>
#include <Instrumentor.h>

#include <SLGLFWInterface.h>

//-----------------------------------------------------------------------------
//! Forward declaration of the scene definition function from AppArucoPenLoad.cpp
extern void appDemoLoadScene(SLProjectScene* s, SLSceneView* sv, SLSceneID sceneID);
extern bool onUpdateVideo();

//-----------------------------------------------------------------------------
// Global application variables
static GLFWwindow* window;                     //!< The global glfw window handle
static SLint       svIndex;                    //!< SceneView index
static SLint       scrWidth;                   //!< Window width at start up
static SLint       scrHeight;                  //!< Window height at start up
static SLbool      fixAspectRatio;             //!< Flag if wnd aspect ratio should be fixed
static SLfloat     scrWdivH;                   //!< aspect ratio screen width divided by height
static SLint       dpi = 142;                  //!< Dot per inch resolution of screen
static SLint       startX;                     //!< start position x in pixels
static SLint       startY;                     //!< start position y in pixels
static SLint       mouseX;                     //!< Last mouse position x in pixels
static SLint       mouseY;                     //!< Last mouse position y in pixels
static SLVec2i     touch2;                     //!< Last finger touch 2 position in pixels
static SLVec2i     touchDelta;                 //!< Delta between two fingers in x
static SLint       lastWidth;                  //!< Last window width in pixels
static SLint       lastHeight;                 //!< Last window height in pixels
static SLfloat     lastMouseDownTime = 0.0f;   //!< Last mouse press time
static SLKey       modifiers         = K_none; //!< last modifier keys
static SLbool      fullscreen        = false;  //!< flag if window is in fullscreen mode

//-----------------------------------------------------------------------------
/*!
onPaint: Paint event handler that passes the event to the slPaint function. 
*/
SLbool onPaint()
{
    PROFILE_SCOPE("GLFW::onPaint");

    if (AppDemo::sceneViews.empty())
        return false;
    SLSceneView* sv = AppDemo::sceneViews[svIndex];

    // If live video image is requested grab it and copy it
    if (CVCapture::instance()->videoType() != VT_NONE)
    {
        float viewportWdivH = sv->viewportWdivH();
        CVCapture::instance()->grabAndAdjustForSL(viewportWdivH);
    }

    ////////////////////////////////////////////////
    bool trackingGotUpdated = onUpdateVideo();
    bool jobIsRunning       = slUpdateParallelJob();
    bool viewsNeedsRepaint  = slPaintAllViews();
    ////////////////////////////////////////////////

    // Fast copy the back buffer to the front buffer. This is OS dependent.
    glfwSwapBuffers(window);

    // Show the title generated by the scene library (FPS etc.)
    glfwSetWindowTitle(window, sv->windowTitle().c_str());

    return trackingGotUpdated || jobIsRunning || viewsNeedsRepaint;
}
//-----------------------------------------------------------------------------
/*!
onResize: Event handler called on the resize event of the window. This event
should called once before the onPaint event.
*/
static void onResize(GLFWwindow* myWindow, int width, int height)
{
    if (AppDemo::sceneViews.empty()) return;
    SLSceneView* sv = AppDemo::sceneViews[svIndex];

    if (fixAspectRatio)
    {
        //correct target width and height
        if ((float)height * scrWdivH <= (float)width)
        {
            width  = (int)((float)height * scrWdivH);
            height = (int)((float)width / scrWdivH);
        }
        else
        {
            height = (int)((float)width / scrWdivH);
            width  = (int)((float)height * scrWdivH);
        }
    }

    lastWidth  = width;
    lastHeight = height;

    // width & height are in screen coords.
    slResize(svIndex, width, height);

    onPaint();
}
//-----------------------------------------------------------------------------
/*!
Mouse button event handler forwards the events to the slMouseDown or slMouseUp.
Two finger touches of touch devices are simulated with ALT & CTRL modifiers.
*/
static void onMouseButton(GLFWwindow* myWindow,
                          int         button,
                          int         action,
                          int         mods)
{
    SLint x = mouseX;
    SLint y = mouseY;
    startX  = x;
    startY  = y;

    // Translate modifiers
    modifiers = K_none;
    if ((uint)mods & (uint)GLFW_MOD_SHIFT) modifiers = (SLKey)(modifiers | K_shift);
    if ((uint)mods & (uint)GLFW_MOD_CONTROL) modifiers = (SLKey)(modifiers | K_ctrl);
    if ((uint)mods & (uint)GLFW_MOD_ALT) modifiers = (SLKey)(modifiers | K_alt);

    if (action == GLFW_PRESS)
    {
        SLfloat mouseDeltaTime = (SLfloat)glfwGetTime() - lastMouseDownTime;
        lastMouseDownTime      = (SLfloat)glfwGetTime();

        // handle double click
        if (mouseDeltaTime < 0.3f)
        {
            switch (button)
            {
                case GLFW_MOUSE_BUTTON_LEFT:
                    slDoubleClick(svIndex, MB_left, x, y, modifiers);
                    break;
                case GLFW_MOUSE_BUTTON_RIGHT:
                    slDoubleClick(svIndex, MB_right, x, y, modifiers);
                    break;
                case GLFW_MOUSE_BUTTON_MIDDLE:
                    slDoubleClick(svIndex, MB_middle, x, y, modifiers);
                    break;
                default: break;
            }
        }
        else // normal mouse clicks
        {
            switch (button)
            {
                case GLFW_MOUSE_BUTTON_LEFT:
                    if (modifiers & K_alt && modifiers & K_ctrl)
                        slTouch2Down(svIndex, x - 20, y, x + 20, y);
                    else
                        slMouseDown(svIndex, MB_left, x, y, modifiers);
                    break;
                case GLFW_MOUSE_BUTTON_RIGHT:
                    slMouseDown(svIndex, MB_right, x, y, modifiers);
                    break;
                case GLFW_MOUSE_BUTTON_MIDDLE:
                    slMouseDown(svIndex, MB_middle, x, y, modifiers);
                    break;
                default: break;
            }
        }
    }
    else
    { // flag end of mouse click for long touches
        startX = -1;
        startY = -1;

        switch (button)
        {
            case GLFW_MOUSE_BUTTON_LEFT:
                slMouseUp(svIndex, MB_left, x, y, modifiers);
                break;
            case GLFW_MOUSE_BUTTON_RIGHT:
                slMouseUp(svIndex, MB_right, x, y, modifiers);
                break;
            case GLFW_MOUSE_BUTTON_MIDDLE:
                slMouseUp(svIndex, MB_middle, x, y, modifiers);
                break;
            default: break;
        }
    }
}
//-----------------------------------------------------------------------------
/*!
Mouse move event handler forwards the events to slMouseMove or slTouch2Move.
*/
static void onMouseMove(GLFWwindow* myWindow,
                        double      x,
                        double      y)
{
    // x & y are in screen coords.
    mouseX = (int)x;
    mouseY = (int)y;

    if (modifiers & K_alt && modifiers & K_ctrl)
        slTouch2Move(svIndex, (int)(x - 20), (int)y, (int)(x + 20), (int)y);
    else
        slMouseMove(svIndex, (int)x, (int)y);
}
//-----------------------------------------------------------------------------
/*!
Mouse wheel event handler forwards the events to slMouseWheel
*/
static void onMouseWheel(GLFWwindow* myWindow,
                         double      xscroll,
                         double      yscroll)
{
    // make sure the delta is at least one integer
    int dY = (int)yscroll;
    if (dY == 0) dY = (int)(Utils::sign(yscroll));

    slMouseWheel(svIndex, dY, modifiers);
}
//-----------------------------------------------------------------------------
/*!
Key event handler sets the modifier key state & forwards the event to
the slKeyPress function.
*/
static void onKeyPress(GLFWwindow* myWindow,
                       int         GLFWKey,
                       int         scancode,
                       int         action,
                       int         mods)
{
    SLKey key = SLGLFWInterface::mapKeyToSLKey(GLFWKey);

    if (action == GLFW_PRESS)
    {
        switch (key)
        {
            case K_ctrl: modifiers = (SLKey)(modifiers | K_ctrl); return;
            case K_alt: modifiers = (SLKey)(modifiers | K_alt); return;
            case K_shift: modifiers = (SLKey)(modifiers | K_shift); return;
            default: break;
        }
    }
    else if (action == GLFW_RELEASE)
    {
        switch (key)
        {
            case K_ctrl: modifiers = (SLKey)(modifiers ^ K_ctrl); return;
            case K_alt: modifiers = (SLKey)(modifiers ^ K_alt); return;
            case K_shift: modifiers = (SLKey)(modifiers ^ K_shift); return;
            default: break;
        }
    }

    // Special treatment for ESC key
    if (key == K_esc && action == GLFW_RELEASE)
    {
        if (fullscreen)
        {
            fullscreen = !fullscreen;
            glfwSetWindowSize(myWindow, scrWidth, scrHeight);
            glfwSetWindowPos(myWindow, 10, 30);
        }
        if (AppArucoPenGui::hideUI)
            AppArucoPenGui::hideUI = false;
    }
    // Toggle fullscreen mode
    else if (key == K_F9 && action == GLFW_PRESS)
    {
        fullscreen = !fullscreen;

        if (fullscreen)
        {
            GLFWmonitor*       primary = glfwGetPrimaryMonitor();
            const GLFWvidmode* mode    = glfwGetVideoMode(primary);
            glfwSetWindowSize(myWindow, mode->width, mode->height);
            glfwSetWindowPos(myWindow, 0, 0);
        }
        else
        {
            glfwSetWindowSize(myWindow, scrWidth, scrHeight);
            glfwSetWindowPos(myWindow, 10, 30);
        }
    }
    else
    {
        // Keyboard shortcuts for next or previous sceneID loading
        if (modifiers & K_alt && modifiers & K_shift)
        {
            SLSceneView* sv = AppDemo::sceneViews[0];
            if (action == GLFW_PRESS)
            {
                if (key == '0' && sv)
                {
                    appDemoLoadScene(AppDemo::scene, sv, SID_Empty);
                    SL_LOG("Loading SceneID: %d", AppDemo::sceneID);
                }
                else if (key == K_left && sv && AppDemo::sceneID > 0)
                {
                    appDemoLoadScene(AppDemo::scene, sv, (SLSceneID)(AppDemo::sceneID - 1));
                    SL_LOG("Loading SceneID: %d", AppDemo::sceneID);
                }
                else if (key == K_right && sv && AppDemo::sceneID < SID_Maximal - 1)
                {
                    appDemoLoadScene(AppDemo::scene, sv, (SLSceneID)(AppDemo::sceneID + 1));
                    SL_LOG("Loading SceneID: %d", AppDemo::sceneID);
                }
            }
            return;
        }

        if (action == GLFW_PRESS)
            slKeyPress(svIndex, key, modifiers);
        else if (action == GLFW_RELEASE)
            slKeyRelease(svIndex, key, modifiers);
    }
}
//-----------------------------------------------------------------------------
//! Event handler for GLFW character input
void onCharInput(GLFWwindow*, SLuint c)
{
    slCharInput(svIndex, c);
}

//-----------------------------------------------------------------------------
//! Alternative SceneView creation C-function passed by slCreateSceneView
SLSceneView* createAppDemoSceneView(SLProjectScene* scene,
                                    int             curDPI,
                                    SLInputManager& inputManager)
{
    // The sceneview will be deleted by SLScene::~SLScene()
    return new AppArucoPenSceneView(scene, curDPI, inputManager);
}
//-----------------------------------------------------------------------------
//! Initialises all GLFW and GL3W stuff
void initGLFW(int screenWidth, int screenHeight)
{
    SLGLFWInterface::initialize();
    window = SLGLFWInterface::createWindow(screenWidth, screenHeight, "My Title", 1, 4);

    //get real window size
    glfwGetWindowSize(window, &scrWidth, &scrHeight);

    SLGLFWInterface::createGLContext();

    glfwSetWindowTitle(window, "SLProject Test Application");
    glfwSetWindowPos(window, 50, 100);

    // With GLFW ImGui draws the cursor
    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);

    // Get GL errors that occurred before our framework is involved
    GET_GL_ERROR;

    // Set your own physical screen dpi
    Utils::log("SLProject", "------------------------------------------------------------------");
    Utils::log("SLProject",
               "GUI-Framwork     : GLFW (Version: %d.%d.%d",
               GLFW_VERSION_MAJOR,
               GLFW_VERSION_MINOR,
               GLFW_VERSION_REVISION);
    Utils::log("SLProject",
               "Resolution (DPI) : %d",
               dpi);

    // Set GLFW callback functions
    glfwSetKeyCallback(window, onKeyPress);
    glfwSetCharCallback(window, onCharInput);
    glfwSetWindowSizeCallback(window, onResize);
    glfwSetMouseButtonCallback(window, onMouseButton);
    glfwSetCursorPosCallback(window, onMouseMove);
    glfwSetScrollCallback(window, onMouseWheel);
}
//-----------------------------------------------------------------------------
//! Inits all for SLProject library
void initSL(SLVstring& cmdLineArgs)
{
    // get executable path
    SLstring projectRoot = SLstring(SL_PROJECT_ROOT);
    SLstring configDir   = Utils::getAppsWritableDir();
    slSetupExternalDir(projectRoot + "/data/");
    //Utils::dumpFileSystemRec("SLProject",  projectRoot + "/data");

    //setup platform dependent data path
    AppDemo::calibFilePath = configDir;
    AppDemo::calibIniPath  = projectRoot + "/data/calibrations/";                                 // for calibInitPath
    CVCapture::instance()->loadCalibrations(Utils::ComputerInfos::get(), AppDemo::calibFilePath); // for calibrations made

    /////////////////////////////////////////////////////////
    slCreateAppAndScene(cmdLineArgs,
                        projectRoot + "/data/",
                        projectRoot + "/data/shaders/",
                        projectRoot + "/data/models/",
                        projectRoot + "/data/images/textures/",
                        projectRoot + "/data/images/fonts/",
                        projectRoot + "/data/videos/",
                        configDir,
                        "AppDemoGLFW",
                        (void*)appDemoLoadScene);
    /////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////
    slCreateSceneView(AppDemo::scene,
                      scrWidth,
                      scrHeight,
                      dpi,
                      (SLSceneID)SL_STARTSCENE,
                      (void*)&onPaint,
                      nullptr,
                      (void*)createAppDemoSceneView,
                      (void*)AppArucoPenGui::build,
                      (void*)AppArucoPenGui::loadConfig,
                      (void*)AppArucoPenGui::saveConfig);
    /////////////////////////////////////////////////////////
}
//-----------------------------------------------------------------------------
/*!
The C main procedure running the GLFW GUI application.
*/
int main(int argc, char* argv[])
{
    // set command line arguments
    SLVstring cmdLineArgs;
    for (int i = 0; i < argc; i++)
        cmdLineArgs.push_back(SLstring(argv[i]));

    scrWidth       = 1280;
    scrHeight      = 720;
    scrWdivH       = (float)scrWidth / (float)scrHeight;
    fixAspectRatio = false;
    touch2.set(-1, -1);
    touchDelta.set(-1, -1);

    initGLFW(scrWidth, scrHeight);
    initSL(cmdLineArgs);

    // Event loop
    while (!slShouldClose())
    {
        /////////////////////////////
        SLbool doRepaint = onPaint();
        /////////////////////////////

        // if no updated occurred wait for the next event (power saving)
        if (!doRepaint)
            //todo ghm1: glfwWaitEvents is not working on my machine (maybe https://github.com/glfw/glfw/issues/685)
            glfwWaitEvents();
        else
            glfwPollEvents();
    }

    slTerminate();

    glfwDestroyWindow(window);
    glfwTerminate();
    return 0;
}
//-----------------------------------------------------------------------------
